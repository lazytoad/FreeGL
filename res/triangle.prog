/*struct Point
{
    vec3 v;
    vec2 t;
};

struct TriStruct
{
	Point p[3];
};*/

#define pointSize 5
#define triSize 15

layout(rgba8, binding = 0) uniform image2D destTex;
layout(rgba8, binding = 2) uniform image2D srcTex;

layout(binding = 0) readonly buffer indata {
	float elements[];
};

/*layout(packed, binding = 1) writeonly buffer indata2 {
	float outdata[40];
};*/

uniform vec2 add;
uniform vec2 scale;

layout( local_size_x = 1024 ) in;
/*
vec3 BaryCoords(in vec2 p, in vec2 tri[3], vec2 p10, float area2)
{
	vec2 p10 = tri[1] - tri[0];
	vec2 p20 = tri[2] - tri[0];
	float area2 = p10.x * p20.y - p10.y * p20.x;

	if (area2 < 0.1)
		return vec3(-1, -1, -1);

	float s = (area2)*(tri[0].y*tri[2].x - tri[0].x*tri[2].y + (p20.y)*p.x - (p20.x)*p.y);
	float t = (area2)*(tri[0].x*tri[1].y - tri[0].y*tri[1].x - (p10.y)*p.x + (p10.x)*p.y);

	return vec3(s, t, 1 - s - t);
}*/

void main()
{
	uint k = gl_GlobalInvocationID.x;
	uint triangles = elements.length() / 15;

	//imageStore(destTex, ivec2(gl_GlobalInvocationID.xy), vec4(1, 1, 1, 1));
	if (k >= triangles)
		return;

	//imageStore(destTex, ivec2(gl_GlobalInvocationID.xy), vec4(0, 1, 0, 1));

	uint base = k * triSize;

	vec2 tri[3];
	vec2 tex[3];
	vec3 pos3d[3];

	//vec

	for(uint i = 0; i < 3; ++i)
	{
		pos3d[i] = vec3(elements[base + i * pointSize + 0], elements[base + i * pointSize + 1], elements[base + i * pointSize + 2]);
		tri[i] = pos3d[i].xy * scale + add;
		tex[i] = vec2(elements[base + i * pointSize + 3], elements[base + i * pointSize + 4]);
	}
	float lightingMultiplier = normalize(cross(pos3d[1] - pos3d[0], pos3d[2] - pos3d[0])).z;

	vec2 lo = round(tri[2]);
	vec2 hi = round(tri[2]);
	for(uint i = 0; i < 2; ++i)
	{
		lo = min(lo, (round(tri[i])));
		hi = max(hi, (round(tri[i])));
	}


	vec2 p10 = tri[1] - tri[0];
	vec2 p20 = tri[2] - tri[0];
	float area2 = p10.x * p20.y - p10.y * p20.x;
	if (area2 <= 0)
		return;
	
	area2 = 1 / area2;

	float arg1 = tri[0].y*tri[2].x - tri[0].x*tri[2].y;
	float arg2 = tri[0].x*tri[1].y - tri[0].y*tri[1].x;

	for (float j = lo.y; j <= hi.y; ++j)
	{
		for (float i = lo.x; i < hi.x; ++i)
		{
			//vec2 p = vec2(i, j);
			float s = (area2)*(arg1 + (p20.y)*i - (p20.x)*j);
			float t = (area2)*(arg2 - (p10.y)*i + (p10.x)*j);
			float u = 1 - s - t;
			//vec3 bariCoords =  BaryCoords(p, tri);

			//vec3 bariCoords = vec3(s, t, u);

			if (s >= -0.01 && t >= -0.01 && u >= -0.01)
			{
				vec2 texPos = tex[0]  * u +
								tex[1] * s +
								tex[2] * t;
				ivec2 iTexPos = ivec2(texPos * 512);
				vec4 value = imageLoad(srcTex, iTexPos);//ivec2(11, 11));vec4(1, 1, 1, 1);//
				imageStore(destTex, ivec2(i, j), value * lightingMultiplier);
			}
		}
	}
}